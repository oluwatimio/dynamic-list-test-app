{"ast":null,"code":"import { spacingLoose } from '@shopify/polaris-tokens';\nimport debounce$1 from 'lodash/debounce';\nimport { stackedContent } from '../breakpoints.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { getRectForNode } from '../geometry.js';\n\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce$1(() => {\n      this.manageStickyItems();\n    }, 40, {\n      leading: true,\n      trailing: true,\n      maxWait: 40\n    });\n    this.handleScroll = debounce$1(() => {\n      this.manageStickyItems();\n    }, 40, {\n      leading: true,\n      trailing: true,\n      maxWait: 40\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(spacingLoose, 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };","map":{"version":3,"sources":["/Users/timi/Desktop/typescript-test/node_modules/@shopify/polaris/dist/esm/utilities/sticky-manager/sticky-manager.js"],"names":["spacingLoose","debounce$1","stackedContent","scrollable","dataPolarisTopBar","getRectForNode","StickyManager","constructor","container","stickyItems","stuckItems","topBarOffset","handleResize","manageStickyItems","leading","trailing","maxWait","handleScroll","setContainer","registerStickyItem","stickyItem","push","unregisterStickyItem","nodeToRemove","nodeIndex","findIndex","stickyNode","splice","el","isDocument","setTopBarOffset","addEventListener","window","removeScrollListener","removeEventListener","length","scrollTop","scrollTopFor","containerTop","top","forEach","handlePositioning","sticky","left","width","evaluateStickyItem","updateStuckItems","placeHolderNode","boundingElement","offset","disableWhenStacked","matches","stickyOffset","getOffset","parseInt","scrollPosition","placeHolderNodeCurrentTop","getBoundingClientRect","stickyItemHeight","height","stickyItemBottomPosition","bottom","item","isNodeStuck","addStuckItem","removeStuckItem","node","count","stuckNodesLength","nodeRect","stuckNode","stuckNodeRect","horizontallyOverlaps","nodeFound","topbarElement","querySelector","selector","clientHeight","document","body","documentElement","rect1","rect2","rect1Left","rect1Right","rect2Left","rect2Right"],"mappings":"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","sourcesContent":["import { spacingLoose } from '@shopify/polaris-tokens';\nimport debounce$1 from 'lodash/debounce';\nimport { stackedContent } from '../breakpoints.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { getRectForNode } from '../geometry.js';\n\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce$1(() => {\n      this.manageStickyItems();\n    }, 40, {\n      leading: true,\n      trailing: true,\n      maxWait: 40\n    });\n    this.handleScroll = debounce$1(() => {\n      this.manageStickyItems();\n    }, 40, {\n      leading: true,\n      trailing: true,\n      maxWait: 40\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(spacingLoose, 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };\n"]},"metadata":{},"sourceType":"module"}